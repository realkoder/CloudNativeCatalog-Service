# Cloud Native... Chapter 2 NOTES


## Utility Commands
pwd should be appplication root directory.

Boot the spring application with gradle.
```shell
./gradlew bootRun
```

<br>

---
### Test w gradle
The cli command below executes gradle test - run this to run test.
Reason behind the autogenerated test class with 
springboottest annotated is to test that the whole 
spring application can start up without any errors.
```shell
./gradlew test
```
<br>

---
### Use Of Docker

This command will clean-up, as soon as container exits
it gets deleted.
``` shell
docker run --rm my-image
```

#### Building a Docker Image with Gradle and Spring Boot
When you run `./gradlew bootBuildImage`, Gradle goes through the following steps:

1. **Build the Project:**
   - Gradle first builds your Spring Boot project, compiling the source code, running tests, and assembling the necessary artifacts.

2. **Create a Docker Image:**
   - Once the project is built, the Spring Boot Gradle Plugin uses the Paketo Buildpacks to create a Docker image for your application. Buildpacks are a framework for transforming application source code into container images. They handle tasks such as dependency resolution, build, and configuration.

3. **Docker Image Configuration:**
   - The Docker image created is configured to run your Spring Boot application using the JAR file generated during the build. The image may include a minimal operating system layer, a JRE (Java Runtime Environment), and any dependencies needed by your application.

4. **Result:**
   - After the process completes, you will have a Docker image for your Spring Boot application that you can run using a container runtime like Docker.

```shell
./gradlew bootBuildImage
```
After the image is created execute this:
flag --plateform is because it's not supporting ARM64 yet
```shell
docker run --rm --name catalog-service -p 8080:8080 15cad --platform linux/amd64
```

<br>

---

### Using minikube for Kubernetes

```bash
brew install minikube
```

Running a local Kubernetes cluster with minikube requires a container runtime or a virtual machine manager. 
Since we are already using Docker, that’s what we’re going to use. Under the hood, any minikube cluster will 
run as a Docker container.
After installing minikube, you can start a new local Kubernetes cluster using the Docker driver. 
The first time you run this command, it will take a few minutes to download all the components needed to run the cluster:
```bash
minikube start --driver=docker
```

I recommend making Docker the default driver for minikube by running the follow- ing command:
```bash
minikube config set driver docker
```

To interact with the newly created Kubernetes cluster, you need to install kubectl, the Kubernetes CLI. 
Installation instructions are available on the official website (https:// kubernetes.io/docs/tasks/tools). 
On macOS and Linux, you can install it with Home- brew as follows:
```bash
brew install kubectl
```

Then you can verify that the minikube cluster is started correctly and check that a node is running in your local cluster:
```bash 
kubectl get nodes
NAME       STATUS   ROLES                  AGE     VERSION
minikube   Ready    control-plane,master   2m20s   v1.24.3
```

I recommend stopping minikube whenever you don’t need it to free up resources in your local environment:
```bash
minikube stop
```
